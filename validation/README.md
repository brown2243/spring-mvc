## 12. 검증1 - Validation

### 40. 검증 요구사항

- **웹 서비스는 폼 입력시 오류가 발생하면, 고객이 입력한 데이터를 유지한 상태로 어떤 오류가 발생했는지 친절하게 알려주어야 한다.**
- **컨트롤러의 중요한 역할중 하나는 HTTP 요청이 정상인지 검증하는 것이다.**

- 클라이언트 검증은 조작할 수 있으므로 보안에 취약하다.
- 서버만으로 검증하면, 즉각적인 고객 사용성이 부족해진다.
- **최종적으로 서버 검증은 필수**
- API 방식을 사용하면 API 스펙을 잘 정의해서 검증 오류를 API 응답 결과에 잘 남겨주어야 함

### 41. 프로젝트 설정 V1

### 42. 검증 직접 처리 - 소개

### 43. 검증 직접 처리 - 개발

- 입력값을 검증해 에러가 있다면 맵에 담아서 모델로 전달

- errors?. 은 errors 가 null 일때 NullPointerException 이 발생하는 대신, null 을 반환하는 문법이다.
  - th:if 에서 null 은 실패로 처리되므로 오류 메시지가 출력되지 않는다.
  - 이것은 스프링의 SpringEL이 제공하는 문법이다.
  - 내눈엔 옵셔널체이닝으로 보임

#### 남은 문제점

- 뷰 템플릿에서 중복 처리가 많다. 뭔가 비슷하다.
- 타입 오류 처리가 안된다. Item 의 price , quantity 같은 숫자 필드는 타입이 Integer 이므로 문자 타입으로 설정하는 것이 불가능하다.
  - 숫자 타입에 문자가 들어오면 오류가 발생한다. 그런데 이러한 오류는 스프링 MVC에서 컨트롤러에 진입하기도 전에 예외가 발생하기 때문에, 컨트롤러가 호출되지도 않고, 400 예외가 발생하면서 오류 페이지를 띄워준다.
- Item 의 price 에 문자를 입력하는 것 처럼 타입 오류가 발생해도 고객이 입력한 문자를 화면에 남겨야 한다.
  - 만약 컨트롤러가 호출된다고 가정해도 Item 의 price 는 Integer 이므로 문자를 보관할 수가 없다. 결국 문자는 바인딩이 불가능하므로 고객이 입력한 문자가 사라지게 되고, 고객은 본인이 어떤 내용을 입력해서 오류가 발생했는지 이해하기 어렵다.
  - 결국 고객이 입력한 값도 어딘가에 별도로 관리가 되어야 한다.

### 44. 프로젝트 준비 V2

### 45. BindingResult1

- DTO를 발리데이션하는 내용이 아니여서 아쉽다...
- 타임리프는 스프링의 `BindingResult` 를 활용해서 편리하게 검증 오류를 표현하는 기능을 제공한다.
- `#fields` : `#fields` 로 `BindingResult` 가 제공하는 검증 오류에 접근할 수 있다.
- `th:errors` : 해당 필드에 오류가 있는 경우에 태그를 출력한다. `th:if` 의 편의 버전이다.
- `th:errorclass` : `th:field` 에서 지정한 필드에 오류가 있으면 class 정보를 추가한다.

### 46. BindingResult2

- 스프링이 제공하는 검증 오류를 보관하는 객체이다.
- BindingResult 가 있으면 @ModelAttribute 에 데이터 바인딩 시 오류가 발생해도 컨트롤러가 호출된다!

  - 예) @ModelAttribute에 바인딩 시 타입 오류가 발생하면?
  - BindingResult가 없으면 400 오류가 발생하면서 컨트롤러가 호출되지 않고, 오류 페이지로 이동하지만 있으면 오류 정보(FieldError)를 BindingResult 에 담아서 컨트롤러를 정상 호출한다.

- BindingResult에 검증 오류를 적용하는 3가지 방법

  - @ModelAttribute 의 객체에 타입 오류 등으로 바인딩이 실패하는 경우 스프링이 FieldError 생성해서 BindingResult 에 넣어준다.
  - 개발자가 직접 넣어준다.
  - Validator 사용

- BindingResult 는 인터페이스이고, Errors 인터페이스를 상속받고 있다.
- 주로 관례상 BindingResult 를 많이 사용한다.

### 47. FieldError, ObjectError

- `FieldError` 는 두 가지 생성자를 제공한다.

  - `objectName` : 오류가 발생한 객체 이름
  - `field` : 오류 필드
  - `rejectedValue` : 사용자가 입력한 값(거절된 값)
  - `bindingFailure` : 타입 오류 같은 바인딩 실패인지, 검증 실패인지 구분 값
  - `codes` : 메시지 코드
  - `arguments` : 메시지에서 사용하는 인자
  - `defaultMessage` : 기본 오류 메시지

- 사용자의 입력 데이터가 컨트롤러의 @ModelAttribute 에 바인딩되는 시점에 오류가 발생하면 모델 객체에 사용자 입력 값을 유지하기 어렵다.
  - 예를 들어서 가격에 숫자가 아닌 문자가 입력된다면 가격은 Integer 타입이므로 문자를 보관할 수 있는 방법이 없다.
  - 그래서 오류가 발생한 경우 사용자 입력 값을 보관하는 별도의 방법이 필요하다.
  - 그리고 이렇게 보관한 사용자 입력 값을 검증 오류 발생시 화면에 다시 출력하면 된다.
- FieldError 는 오류 발생시 사용자 입력 값을 저장하는 기능을 제공한다.

  - rejectedValue 가 바로 오류 발생시 사용자 입력 값을 저장하는 필드다.
  - bindingFailure 는 타입 오류 같은 바인딩이 실패했는지 여부를 적어주면 된다.

- 타임리프의 사용자 입력 값 유지

  - `th:field="*{price}"`
  - 정상 상황에는 모델 객체의 값을 사용하지만, 오류가 발생하면 FieldError 에서 보관한 값을 사용해서 값을 출력

- 스프링의 바인딩 오류 처리
  - 타입 오류로 바인딩에 실패하면 스프링은 FieldError 를 생성하면서 사용자가 입력한 값을 넣어둔다. 그리고 해당오류를 BindingResult 에 담아서 컨트롤러를 호출한다.

### 48. 오류 코드와 메시지 처리1

### 49. 오류 코드와 메시지 처리2

### 50. 오류 코드와 메시지 처리3

### 51. 오류 코드와 메시지 처리4

### 52. 오류 코드와 메시지 처리5

### 53. 오류 코드와 메시지 처리6

### 54. Validator 분리1

### 55. Validator 분리2

### 56. 정리
