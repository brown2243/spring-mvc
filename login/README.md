## 14. 로그인 처리1 - 쿠키, 세션

### 71. 로그인 요구사항

### 72. 프로젝트 생성

- **도메인이 가장 중요하다.**
  - 도메인 = 화면, UI, 기술 인프라 등등의 영역은 제외한 시스템이 구현해야 하는 핵심 비즈니스 업무 영역을 말함
- 향후 web을 다른 기술로 바꾸어도 도메인은 그대로 유지할 수 있어야 한다.
  - **이렇게 하려면 web은 domain을 알고있지만 domain은 web을 모르도록 설계해야 한다.**
  - 이것을 web은 domain을 의존하지만, domain은 web을 의존하지 않는다고 표현한다.
  - 예를 들어 web 패키지를 모두 삭제해도 domain에는 전혀 영향이 없도록 의존관계를 설계하는 것이 중요하다.
  - 반대로 이야기하면 domain은 web을 참조하면 안된다.

### 73. 홈 화면

### 74. 회원 가입

### 75. 로그인 기능

### 76. 로그인 처리하기 - 쿠키 사용

- 쿠키에는 영속 쿠키와 세션 쿠키가 있다.
- 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지
- 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지

- 순간 쿠키에 id를 저장하면, 매 요청마다 멤버 객체가 클라이언트에 전달되어야 하니 비효율적이 아닌가 싶었는데, 현 방식에서는 조회는 서버에서만 일어나고 완성된 html에 텍스트로 값만 들어가니 상관없겠다 싶었다.

### 77. 쿠키와 보안 문제

#### 보안 문제

- 쿠키 값은 임의로 변경할 수 있다.
- 클라이언트가 쿠키를 강제로 변경하면 다른 사용자가 된다.
  - 실제 웹브라우저 개발자모드 Application Cookie 변경으로 확인
  - Cookie: memberId=1 Cookie: memberId=2 (다른 사용자의 이름이 보임)
- 쿠키에 보관된 정보는 훔쳐갈 수 있다.
  - 만약 쿠키에 개인정보나, 신용카드 정보가 있다면?
  - 이 정보가 웹 브라우저에도 보관되고, 네트워크 요청마다 계속 클라이언트에서 서버로 전달된다.
  - 쿠키의 정보가 나의 로컬 PC에서 털릴 수도 있고, 네트워크 전송 구간에서 털릴 수도 있다.
- 해커가 쿠키를 한번 훔쳐가면 평생 사용할 수 있다.
- 해커가 쿠키를 훔쳐가서 그 쿠키로 악의적인 요청을 계속 시도할 수 있다.

#### 대안

- 쿠키에 중요한 값을 노출하지 않고, 사용자 별로 예측 불가능한 임의의 토큰(랜덤 값)을 노출하고, 서버에서 토큰과 사용자 id를 매핑해서 인식한다. 서버에서 토큰을 관리한다.
  - 토큰은 해커가 임의의 값을 넣어도 찾을 수 없도록 예상 불가능 해야 한다.
- 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 해당 토큰의 만료시간을 짧게(예: 30분) 유지한다.
- 또는 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거하면 된다.

### 78. 로그인 처리하기 - 세션 동작 방식

- 클라이언트와 서버는 추정 불가능한 임의의 식별자 값으로 연결해야 한다.
- 서버에 중요한 정보를 보관하고 연결을 유지하는 방법을 세션이라 한다.

- 세션 ID를 생성하는데, 추정 불가능해야 한다.
  - UUID는 추정이 불가능하다.
- 생성된 세션 ID와 세션에 보관할 값( memberA )을 서버의 세션 저장소에 보관한다.

- 클라이언트와 서버는 결국 쿠키로 연결이 되어야 한다.
- 서버는 클라이언트에 mySessionId 라는 이름으로 세션ID 만 쿠키에 담아서 전달한다.
- 클라이언트는 쿠키 저장소에 mySessionId 쿠키를 보관한다.
- **중요한 포인트는 회원과 관련된 정보는 전혀 클라이언트에 전달하지 않는다**는 것이다.
- 오직 추정 불가능한 세션 ID만 쿠키를 통해 클라이언트에 전달한다.

### 79. 로그인 처리하기 - 세션 직접 만들기

- 세션 관리는 크게 다음 3가지 기능을 제공하면 된다.
- 세션 생성
  - sessionId 생성 (임의의 추정 불가능한 랜덤 값)
  - 세션 저장소에 sessionId와 보관할 값 저장
  - sessionId로 응답 쿠키를 생성해서 클라이언트에 전달
- 세션 조회
  - 클라이언트가 요청한 sessionId 쿠키의 값으로, 세션 저장소에 보관한 값 조회
- 세션 만료
- 클라이언트가 요청한 sessionId 쿠키의 값으로, 세션 저장소에 보관한 sessionId와 값 제거

### 80. 로그인 처리하기 - 직접 만든 세션 적용

- 이번 시간에는 세션과 쿠키의 개념을 명확하게 이해하기 위해서 직접 만들어보았다.
- 사실 세션이라는 것이 뭔가 특별한 것이 아니라 단지 쿠키를 사용하는데, 서버에서 데이터를 유지하는 방법일 뿐이라는 것을 이해했을 것이다.

### 81. 로그인 처리하기 - 서블릿 HTTP 세션1

- 세션이라는 개념은 대부분의 웹 애플리케이션에 필요한 것이다. 어쩌면 웹이 등장하면서 부터 나온 문제이다.
- 서블릿은 세션을 위해 HttpSession 이라는 기능을 제공하는데, 지금까지 나온 문제들을 해결해준다.
- 우리가 직접 구현한 세션의 개념이 이미 구현되어 있고, 더 잘 구현되어 있다.

- 서블릿을 통해 HttpSession 을 생성하면 다음과 같은 쿠키를 생성한다.
- 쿠키 이름이 JSESSIONID 이고, 값은 추정 불가능한 랜덤 값이다.
- 세션을 찾아서 사용하는 시점에는 `create: false` 옵션을 사용해서 세션을 생성하지 않아야 한다.

### 82. 로그인 처리하기 - 서블릿 HTTP 세션2

- `@SessionAttribute(name = "loginMember", required = false) Member loginMember`

  - 이미 로그인 된 사용자를 찾을 때는 다음과 같이 사용하면 된다.
  - 참고로 이 기능은 세션을 생성하지 않는다.

- 서버 입장에서 웹 브라우저가 쿠키를 지원하는지 하지 않는지 최초에는 판단하지 못하므로, 쿠키 값도 전달하고, URL에 `jsessionid`도 함께 전달한다.
- URL 전달 방식을 끄고 항상 쿠키를 통해서만 세션을 유지하고 싶으면 다음 옵션을 넣어주면 된다.
  - `server.servlet.session.tracking-modes=cookie`

### 83. 세션 정보와 타임아웃 설정

- sessionId : 세션Id, JSESSIONID 의 값이다.
  - 예) 34B14F008AA3527C9F8ED620EFD7A4E1
- maxInactiveInterval : 세션의 유효 시간
  - 예) 1800초, (30분)
- creationTime : 세션 생성일시
- lastAccessedTime : 세션과 연결된 사용자가 최근에 서버에 접근한 시간
  - 클라이언트에서 서버로 sessionId ( JSESSIONID )를 요청한 경우에 갱신된다.
- isNew : 새로 생성된 세션인지, 아니면 이미 과거에 만들어졌고, 조회된 세션인지 여부

- 세션은 사용자가 로그아웃을 직접 호출해서 session.invalidate() 가 호출 되는 경우에 삭제된다.
- 그런데 대부분의 사용자는 로그아웃을 선택하지 않고, 그냥 웹 브라우저를 종료한다.
- 문제는 HTTP가 비 연결성(ConnectionLess) 이므로 서버 입장에서는 해당 사용자가 웹 브라우저를 종료한 것인지 아닌지를 인식할 수 없다.
- 따라서 서버에서 세션데이터를 언제 삭제해야 하는지 판단하기가 어렵다.

- 이 경우 남아있는 세션을 무한정 보관하면 다음과 같은 문제가 발생할 수 있다.

  - 세션과 관련된 쿠키( JSESSIONID )를 탈취 당했을 경우 오랜 시간이 지나도 해당 쿠키로 악의적인 요청을 할 수 있다.
  - 세션은 기본적으로 메모리에 생성된다. 메모리의 크기가 무한하지 않기 때문에 꼭 필요한 경우만 생성해서 사용해야 한다.

- 세션의 종료 시점

  - 사용자가 서버에 최근에 요청한 시간을 기준으로 30분 정도를 유지해준다.
  - 이렇게 하면 사용자가 서비스를 사용하고 있으면, 세션의 생존 시간이 30분으로 계속 늘어나게 된다.

- 세션 타임아웃 설정

  - 스프링 부트로 글로벌 설정
  - `server.servlet.session.timeout=60 : 60초, 기본은 1800(30분)`
    - 글로벌 설정은 분 단위로 설정해야 한다. 60(1분), 120(2분)

- 세션 타임아웃 발생
  - LastAccessedTime 이후로 timeout 시간이 지나면, WAS가 내부에서 해당 세션을 제거한다.

#### 정리

- 서블릿의 HttpSession 이 제공하는 타임아웃 기능 덕분에 세션을 안전하고 편리하게 사용할 수 있다.
- 실무에서 주의할 점은 세션에는 최소한의 데이터만 보관해야 한다는 점이다.
- 보관한 데이터 용량 \* 사용자 수로 세션의 메모리 사용량이 급격하게 늘어나서 장애로 이어질 수 있다.
- 추가로 세션의 시간을 너무 길게 가져가면 메모리 사용이 계속 누적 될 수 있으므로 적당한 시간을 선택하는 것이 필요하다.
- 기본이 30분이라는 것을 기준으로 고민하면 된다.

### 84. 정리

## 15. 로그인 처리2 - 필터, 인터셉터

### 85. 서블릿 필터 - 소개

- 필터는 서블릿이, 인터셉터는 스프링이 제공
- 애플리케이션 여러 로직에서 공통으로 관심이 있는 있는 것을 공통 관심사(cross-cutting concern)라고 한다.
- 공통 관심사는 스프링의 AOP로도 해결할 수 있지만, **웹과 관련된 공통 관심사는 지금부터 설명할 서블릿 필터 또는 스프링 인터셉터를 사용하는 것이 좋다.**

  - 웹과 관련된 공통 관심사를 처리할 때는 HTTP의 헤더나 URL의 정보들이 필요한데, 서블릿 필터나 스프링 인터셉터는 HttpServletRequest 를 제공한다.

- 필터는 서블릿이 지원하는 수문장이다. 필터의 특성은 다음과 같다.
- 필터 흐름 `HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러`
- 필터를 적용하면 필터가 호출 된 다음에 서블릿이 호출된다.
  - 그래서 모든 고객의 요청 로그를 남기는 요구사항이 있다면필터를 사용하면 된다.
  - 참고로 필터는 특정 URL 패턴에 적용할 수 있다. `/*` 이라고 하면 모든 요청에 필터가 적용된다.
- 스프링을 사용하는 경우 여기서 말하는 서블릿은 스프링의 디스패처 서블릿으로 생각하면 된다.

- 필터 제한
- `HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러` - 로그인 사용자
- `HTTP 요청 -> WAS -> 필터` - 비 로그인 사용자(적절하지 않은 요청이라 판단, 서블릿 호출X)
- 필터에서 적절하지 않은 요청이라고 판단하면 거기에서 끝을 낼 수도 있다.

  - 그래서 로그인 여부를 체크하기에 딱 좋다.

- 필터 체인 `HTTP 요청 -> WAS -> 필터1 -> 필터2 -> 필터3 -> 서블릿 -> 컨트롤러`
- 필터는 체인으로 구성되는데, 중간에 필터를 자유롭게 추가할 수 있다.
- 예를 들어서 로그를 남기는 필터를 먼저 적용하고, 그 다음에 로그인 여부를 체크하는 필터를 만들 수 있다.

### 86. 서블릿 필터 - 요청 로그

- 필터를 사용하려면 필터 인터페이스를 구현해야 한다.
- HTTP 요청이 오면 doFilter 가 호출된다.
- `ServletRequest` 는 HTTP 요청이 아닌 경우까지 고려해서 만든 인터페이스이다.
  - `HttpServletRequest`로 다운 케스팅 하면 된다.
- `chain.doFilter(request, response);`

  - 다음 필터가 있으면 필터를 호출하고, 필터가 없으면 서블릿을 호출한다.
  - 만약 이 로직을 호출하지 않으면 다음 단계로 진행되지 않는다.

- 필터를 등록하는 방법은 여러가지가 있지만, 스프링 부트를 사용한다면 `FilterRegistrationBean`을 사용해서 등록하면 된다.
  - setFilter(new LogFilter()) : 등록할 필터를 지정한다.
  - setOrder(1) : 필터는 체인으로 동작한다. 따라서 순서가 필요하다. 낮을 수록 먼저 동작한다.
  - addUrlPatterns("/\*") : 필터를 적용할 URL 패턴을 지정한다. 한번에 여러 패턴을 지정할 수 있다.
- `@ServletComponentScan` `@WebFilter(filterName = "logFilter", urlPatterns = "/*")`로 필터 등록이 가능하지만 필터 순서 조절이 안된다.

### 87. 서블릿 필터 - 인증 체크

### 88. 스프링 인터셉터 - 소개

### 89. 스프링 인터셉터 - 요청 로그

### 90. 스프링 인터셉터 - 인증 체크

### 91. ArgumentResolver 활용

### 92. 정리

## 6. 예외 처리와 오류 페이지

### 93. 프로젝트 생성

### 94. 서블릿 예외 처리 - 시작

### 95. 서블릿 예외 처리 - 오류 화면 제공

### 96. 서블릿 예외 처리 - 오류 페이지 작동 원리

### 97. 서블릿 예외 처리 - 필터

### 98. 서블릿 예외 처리 - 인터셉터

### 99. 스프링 부트 - 오류 페이지1

### 100. 스프링 부트 - 오류 페이지2

### 101. 정리

## 17. API 예외 처리

### 102. 시작

### 103. 스프링 부트 기본 오류 처리

### 104. HandlerExceptionResolver 시작

### 105. HandlerExceptionResolver 활용

### 106. 스프링이 제공하는 ExceptionResolver1

### 107. 스프링이 제공하는 ExceptionResolver2

### 108. @ExceptionHandler

### 109. @ControllerAdvice

### 110. 정리
